#![cfg_attr(not(feature = "std"), no_std)]
#![feature(min_specialization)]

#[cfg(not(feature = "std"))]
mod ext;

#[cfg(not(feature = "std"))]
use ink_primitives::{
    Key,
    KeyPtr,
};
#[cfg(not(feature = "std"))]
use ink_storage::traits::SpreadLayout;
use openbrush::contracts::diamond::*;
#[cfg(not(feature = "std"))]
use openbrush::traits::{
    DefaultEnv,
    Flush,
};

#[cfg(not(feature = "std"))]
const ROOT_KEY: Key = Key::new([0; 32]);

#[cfg(not(feature = "std"))]
const _: () = {
    #[no_mangle]
    #[allow(clippy::nonminimal_bool)]
    fn deploy() {
        let (_, facet_cut) = ink_env::decode_input::<([u8; 4], FacetCut)>().unwrap();

        // Support of diamond
        let mut root_key: KeyPtr = KeyPtr::from(ROOT_KEY);
        let mut storage = <diamond::Data as SpreadLayout>::pull_spread(&mut root_key);
        storage._diamond_cut_facet(&facet_cut).expect("Init diamond cut");
        storage.flush();

        // Support of ownable
        let mut ownable = <ownable::Data as SpreadLayout>::pull_spread(&mut root_key);
        ownable._init_with_owner(<ownable::Data as DefaultEnv>::env().caller());
        ownable.flush();
    }

    #[no_mangle]
    #[allow(clippy::nonminimal_bool)]
    fn call() {
        let selector = ink_env::decode_input::<[u8; 4]>().unwrap();

        let mut root_key: KeyPtr = KeyPtr::from(ROOT_KEY);
        let storage = <diamond::Data as SpreadLayout>::pull_spread(&mut root_key);
        let hash = storage.selector_to_hash.get(&selector).expect("Can't find code hash");

        // Better than usage of `CallBuilder`.
        let _ = ext::delegate_call(
            1 | (1 as u32) << 2, // forward input && tailing call
            hash.as_ref(),
            &[],
            &mut [].as_mut(),
        );
    }
};

// It is stub struct to impl `StorageLayout`. But it can contains all fields with
// zero cost abstraction
pub struct Contract;

#[cfg(feature = "std")]
const _: () = {
    impl ::ink_storage::traits::StorageLayout for Contract {
        fn layout(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> ::ink_metadata::layout::Layout {
            ::ink_metadata::layout::Layout::Struct(::ink_metadata::layout::StructLayout::new([
                ::ink_metadata::layout::FieldLayout::new(
                    ::core::option::Option::Some("diamond"),
                    <diamond::Data as ::ink_storage::traits::StorageLayout>::layout(__key_ptr),
                ),
            ]))
        }
    }
};

#[cfg(feature = "std")]
#[cfg(not(feature = "ink-as-dependency"))]
// Code below is generated by the contract from `ink` folder. It is copy/paste here.
const _: () = {
    #[no_mangle]
    pub fn __ink_generate_metadata() -> ::ink_metadata::MetadataVersioned {
        <::ink_metadata::InkProject as ::core::convert::Into<::ink_metadata::MetadataVersioned>>::into(
            ::ink_metadata::InkProject::new(
                <Contract as ::ink_storage::traits::StorageLayout>::layout(
                    &mut <::ink_primitives::KeyPtr as ::core::convert::From<::ink_primitives::Key>>::from(
                        <::ink_primitives::Key as ::core::convert::From<[::core::primitive::u8; 32usize]>>::from(
                            [0x00_u8; 32usize],
                        ),
                    ),
                ),
                ::ink_metadata::ContractSpec::new()
                    .constructors([::ink_metadata::ConstructorSpec::from_label("new")
                        .selector([0x9B_u8, 0xAE_u8, 0x9D_u8, 0x5E_u8])
                        .args([::ink_metadata::MessageParamSpec::new("diamond_facet")
                            .of_type(::ink_metadata::TypeSpec::with_name_segs::<FacetCut, _>(
                                ::core::iter::IntoIterator::into_iter(["FacetCut"]).map(::core::convert::AsRef::as_ref),
                            ))
                            .done()])
                        .payable(false)
                        .docs([])
                        .done()])
                    .messages([::ink_metadata::MessageSpec::from_label("forward")
                        .selector([0x45_u8, 0x75_u8, 0x3C_u8, 0x2B_u8])
                        .args([])
                        .returns(::ink_metadata::ReturnTypeSpec::new(::core::option::Option::None))
                        .mutates(false)
                        .payable(true)
                        .docs([])
                        .done()])
                    .events([])
                    .docs([])
                    .done(),
            ),
        )
    }
};
