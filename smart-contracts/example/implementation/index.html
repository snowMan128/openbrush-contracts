<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<title data-react-helmet="true">Notes about methods | OpenBrush</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://docs.openbrush.io/smart-contracts/example/implementation"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Notes about methods | OpenBrush"><meta data-react-helmet="true" name="description" content="In this section, we describe the implementation of the functions of our lending"><meta data-react-helmet="true" property="og:description" content="In this section, we describe the implementation of the functions of our lending"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.svg"><link data-react-helmet="true" rel="canonical" href="https://docs.openbrush.io/smart-contracts/example/implementation"><link data-react-helmet="true" rel="alternate" href="https://docs.openbrush.io/smart-contracts/example/implementation" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://docs.openbrush.io/smart-contracts/example/implementation" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.3900dd10.css">
<link rel="preload" href="/assets/js/runtime~main.93062ece.js" as="script">
<link rel="preload" href="/assets/js/main.5df6b7cd.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="OpenBrush" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/logo-dark.svg" alt="OpenBrush" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/smart-contracts/overview">Examples</a><a class="navbar__item navbar__link" href="/deployment">Deploy</a><a href="https://twitter.com/supercolony_net" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-twitter-link"></a><a href="https://github.com/Supercolony-net/openbrush-contracts" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class="react-toggle toggle_2i4l react-toggle--checked react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/">Getting started</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Smart Contracts</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/access-control">Access Control</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/ownable">Ownable</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/reentrancy-guard">Reentrancy Guard</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/pausable">Pausable</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/payment-splitter">Payment Splitter</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/timelock-controller">Timelock Controller</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist" href="#" tabindex="0">PSP22</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/PSP22/psp22">PSP22</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Extensions</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Utils</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist" href="#" tabindex="0">PSP721</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/PSP721/psp721">PSP721</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Extensions</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist" href="#" tabindex="0">PSP1155</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/PSP1155/psp1155">PSP1155</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">Extensions</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">OpenBrush Example</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/setup_project">Setup the project</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/psp22">Implement PSP-22 contract</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/shares">Shares contract</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/loan">Loan contract</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/data">Data and derive macro</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/impls">Lending impls</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/errors">Errors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/smart-contracts/example/contract">Lending contract</a></li><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/smart-contracts/example/implementation">Notes about methods</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/deployment">Deploy</a></li><li class="menu__list-item"><a class="menu__link" href="/evm-wasm-smart-contracts">EVM vs WASM Smart Contracts</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="markdown"><header><h1>Notes about methods</h1></header><p>In this section, we describe the implementation of the functions of our lending
contract.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="instantiating-contracts"></a>Instantiating contracts<a class="hash-link" href="#instantiating-contracts" title="Direct link to heading">#</a></h2><p>Each asset that we will accept to be lent will have two underlying tokens:
the shares token and the reserves token. The shares token will represent a
user&#x27;s share of the lent asset which they can then withdraw and the reserves
token will represent the amount of asset lent since we don&#x27;t want to keep
track of all addresses and amounts which have borrowed the assets. We will
simply take this amount from the total supply of the underlying reserve token.
So when we are accepting an asset for lending, we need to create a new token
contract for shares and for reserves. We will define an internal function for
this:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI rust"><pre tabindex="0" class="prism-code language-rust codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">fn _instantiate_shares_contract(&amp;self, contract_name: &amp;str, contract_symbol: &amp;str) -&gt; AccountId {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let code_hash = self.lending.shares_contract_code_hash;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let (hash, _) =</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        ink_env::random::&lt;ink_env::DefaultEnvironment&gt;(contract_name.as_bytes()).expect(&quot;Ger random salt&quot;);</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let hash = hash.as_ref();</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let contract = SharesContract::new(Some(String::from(contract_name)), Some(String::from(contract_symbol)))</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        .endowment(10000000000)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        .code_hash(code_hash)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        .salt_bytes(&amp;[hash[0], hash[1], hash[2], hash[3]])</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        .instantiate()</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        .unwrap();</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    contract.to_account_id()</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>This function will instantiate our <code>SharesContract</code> contract and return
the <code>AccountId</code> of the instantiated contract. We will call this function
when allowing assets.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="simulating-oracle"></a>Simulating oracle<a class="hash-link" href="#simulating-oracle" title="Direct link to heading">#</a></h2><p>As mentioned before, we will not be using a price oracle in our example,
but we will use our own simulated oracle. And by simulated we mean adding
some storage fields which hold the info about price of an asset and a function
only callable by the account with <code>MANAGER</code> role, which will set the price of
the asset. For that we define these functions:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI rust"><pre tabindex="0" class="prism-code language-rust codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">#[modifiers(only_role(MANAGER))]</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">default fn set_asset_price(</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    &amp;mut self,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    asset_in: AccountId,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    asset_out: AccountId,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    price: Balance,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">) -&gt; Result&lt;(), LendingError&gt; {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    set_asset_price(self, asset_in, asset_out, price);</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Ok(())</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">/// this internal function will be used to set price of `asset_in` when we deposit `asset_out`</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">/// we are using this function in our example to simulate an oracle</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">pub fn set_asset_price&lt;T: LendingStorage&gt;(instance: &amp;mut T, asset_in: AccountId, asset_out: AccountId, price: Balance) {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    instance.get_mut().asset_price.insert((asset_in, asset_out), price);</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="allowing-assets"></a>Allowing assets<a class="hash-link" href="#allowing-assets" title="Direct link to heading">#</a></h2><p>If we just started lending and borrowing random assets or using random assets
as collateral there would be chaos in our smart contract.
Regarding lending, it would not be a big problem, since if somebody is
willing to borrow an asset, it would generate a profit for the lender.
But if we started accepting random assets as collateral, anyone could just
throw a random coin as collateral and then just for example rug pull it and
also keep the borrowed assets. Because of this we will only accept certain
assets for lending and using as collateral. For an asset to be accepted, an
account with the <code>MANAGER</code> role needs to allow it with the <code>allow_asset</code> function.
We will use a modifier from OpenBrush, which serves similarly to Solidity&#x27;s
function modifiers. The function will look like this:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI rust"><pre tabindex="0" class="prism-code language-rust codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">#[modifiers(only_role(MANAGER))]</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">default fn allow_asset(&amp;mut self, asset_address: AccountId) -&gt; Result&lt;(), LendingError&gt; {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // we will ensure the asset is not accepted already</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if self.is_accepted_lending(asset_address) {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::AssetSupported)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // instantiate the shares of the lended assets</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let shares_address = self._instantiate_shares_contract(&quot;LendingShares&quot;, &quot;LS&quot;);</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // instantiate the reserves of the borrowed assets</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let reserves_address = self._instantiate_shares_contract(&quot;LendingReserves&quot;, &quot;LR&quot;);</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // accept the asset and map shares and reserves to it</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    accept_lending(self, asset_address, shares_address, reserves_address);</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Ok(())</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="lending-assets"></a>Lending assets<a class="hash-link" href="#lending-assets" title="Direct link to heading">#</a></h2><p>For lending the assets  we will use the function <code>lend_assets(asset_address, amount)</code>,
where <code>asset_address</code> is the address of <code>PSP-22</code> we want to deposit and <code>amount</code>
is the amount of asset deposited. Some checks need to be checked to assure the correct
behavior of our contract. The asset deposited needs to be recognized by our contract
(manager must have approved it). If it is not accepted, an error will be returned.
Then the user must have approved the asset to spent by our contract and the user&#x27;s
balance must be greater than or equal to <code>amount</code>. So we will transfer the asset from
the user to the contract, mint shares to the user. To perform a cross contract call
we will be using the references to contracts <code>SharesRef</code>.
We will also add <code>when_not_paused</code> modifier to this function,
so it can be only called when the contract is not paused.
The code will look like this:</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI rust"><pre tabindex="0" class="prism-code language-rust codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">#[modifiers(when_not_paused)]</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">default fn lend_assets(&amp;mut self, asset_address: AccountId, amount: Balance) -&gt; Result&lt;(), LendingError&gt; {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // we will be using these often so we store them in variables</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let lender = Self::env().caller();</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let contract = Self::env().account_id();</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // ensure the user gave allowance to the contract</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if PSP22Ref::allowance(&amp;asset_address, lender, contract) &lt; amount {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::InsufficientAllowanceToLend)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // ensure the user has enough assets</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if PSP22Ref::balance_of(&amp;asset_address, lender) &lt; amount {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::InsufficientBalanceToLend)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // how much assets is already in the contract</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // if the asset is not accepted by the contract, this function will return an error</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let total_asset = self.total_asset(asset_address)?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // transfer the assets from user to the contract|</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    PSP22Ref::transfer_from(&amp;asset_address, lender, contract, amount, Vec::&lt;u8&gt;::new())?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // if no assets were deposited yet we will mint the same amount of shares as deposited `amount`</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let new_shares = if total_asset == 0 {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        amount</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        // else we calculate how much shares will belong us after depositing the `amount`</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        (amount * self.total_shares(asset_address)?) / total_asset</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    };</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let reserve_asset = get_reserve_asset(self, &amp;asset_address)?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // mint the shares token to the user</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    SharesRef::mint(&amp;reserve_asset, lender, new_shares)?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Ok(())</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="borrowing-assets"></a>Borrowing assets<a class="hash-link" href="#borrowing-assets" title="Direct link to heading">#</a></h2><p>The <code>borrow_assets(asset_address, collateral_address, amount)</code> function will
serve for the users to borrow assets from the smart contract.
<code>asset_address</code> is the account id of the asset we want to borrow,
<code>collateral_address</code> is the account id of asset which the user wants
to use as collateral, and <code>amount</code> is the amount of collateral deposited.
Our contract will calculate the value of the deposited collateral and
will give the borrower 70% of the collateral value. For pricing, we would
use an oracle, but in this example, we will use our &#x27;simulated oracle&#x27; -
we will just store the price info in our contract and the admin will
be able to change it. The liquidation price of the loan will be calculated
at 75% of the collateral value. First of all the contract must not be paused,
for which we use modifier <code>when_not_paused</code>. After that, for the borrowing
to succeed, the <code>collateral_address</code> must be accepted by the contract,
the contract needs to have enough allowance to spend the borrower&#x27;s collateral
token, borrower&#x27;s collateral balance must be equal to or greater than <code>amount</code>
and finally, the <code>asset_address</code> must be accepted for borrowing in the
smart contract. After we calculate the liquidation price and borrow amount,
we ensure the contract has enough assets to provide for the borrower,
and we also want the liquidation price of the collateral to be higher than
the borrowed amount. Since we are dealing with integers, entering a very
low amount (below 10) of collateral may result in the liquidation price being
the same as the borrowed amount, which could be exploited. We can surely
handle it in many different ways, but again, it is not the purpose of this
example so we will deal with it this way. When everything is alright, we will
transfer the collateral to the contract, mint an NFT, which stores the
information about the loan, to the borrower, then transfer the asset to the
borrower, and finally, mint the reserve token. We will mint the same amount
that we lent, and we will burn it after the loan is repaid or liquidated.
This reserve token will be used to track the amount of the asset which is
currently borrowed.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI rust"><pre tabindex="0" class="prism-code language-rust codeBlock_rtdJ thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#9CDCFE"><span class="token plain">#[modifiers(when_not_paused)]</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">default fn borrow_assets(</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    &amp;mut self,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    asset_address: AccountId,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    collateral_address: AccountId,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    amount: Balance,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">) -&gt; Result&lt;(), LendingError&gt; {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // we will be using these often so we store them in variables</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let borrower = Self::env().caller();</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let contract = Self::env().account_id();</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // ensure this asset is accepted as collateral</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if !self.is_accepted_collateral(collateral_address) {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::AssetNotSupported)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // ensure the user gave allowance to the contract</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if PSP22Ref::allowance(&amp;collateral_address, borrower, contract) &lt; amount {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::InsufficientAllowanceForCollateral)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // ensure the user has enough collateral assets</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if PSP22Ref::balance_of(&amp;collateral_address, borrower) &lt; amount {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::InsufficientCollateralBalance)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let reserve_asset = get_reserve_asset(self, &amp;asset_address)?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // we will find out the price of deposited collateral</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let price = get_asset_price(self, amount, collateral_address, asset_address);</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // we will set the liquidation price to be 75% of current price</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let liquidation_price = (price * 75) / 100;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // borrow amount is 70% of collateral</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let borrow_amount = (price * 70) / 100;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // ensure the liquidation price is greater than borrowed amount to avoid misuses</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if borrow_amount &gt;= liquidation_price {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::AmountNotSupported)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // ensure we have enough assets in the contract</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    if PSP22Ref::balance_of(&amp;asset_address, contract) &lt; borrow_amount {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        return Err(LendingError::InsufficientBalanceInContract)</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    }</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // we will transfer the collateral to the contract</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    PSP22Ref::transfer_from(&amp;collateral_address, borrower, contract, amount, Vec::&lt;u8&gt;::new())?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // create loan info</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let loan_info = LoanInfo {</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        borrower,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        collateral_token: collateral_address,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        collateral_amount: amount,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        borrow_token: asset_address,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        borrow_amount,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        liquidation_price,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        timestamp: Self::env().block_timestamp(),</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        liquidated: false,</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    };</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    let load_account = LendingStorage::get(self).loan_account;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    LoanRef::create_loan(&amp;load_account, loan_info)?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // transfer assets to borrower</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    PSP22Ref::transfer(&amp;asset_address, borrower, borrow_amount, Vec::&lt;u8&gt;::new())?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    // mint `borrow_amount` of the reserve token</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    SharesRef::mint(&amp;reserve_asset, contract, borrow_amount)?;</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    Ok(())</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/Supercolony-net/openbrush-contracts/tree/main/docs/docs/smart-contracts/example/implementation.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/smart-contracts/example/contract"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Lending contract</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/deployment"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Deploy Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#instantiating-contracts" class="table-of-contents__link">Instantiating contracts</a></li><li><a href="#simulating-oracle" class="table-of-contents__link">Simulating oracle</a></li><li><a href="#allowing-assets" class="table-of-contents__link">Allowing assets</a></li><li><a href="#lending-assets" class="table-of-contents__link">Lending assets</a></li><li><a href="#borrowing-assets" class="table-of-contents__link">Borrowing assets</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 OpenBrush, Supercolony.net.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.93062ece.js"></script>
<script src="/assets/js/main.5df6b7cd.js"></script>
</body>
</html>