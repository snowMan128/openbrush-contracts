"use strict";(self.webpackChunkopenbrush=self.webpackChunkopenbrush||[]).push([[939],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=s(n),d=o,k=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?r.createElement(k,a(a({ref:t},p),{},{components:n})):r.createElement(k,a({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,a[1]=c;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5102:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return p},default:function(){return m}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],c={sidebar_position:1,title:"PSP22 Token Timelock"},l=void 0,s={unversionedId:"smart-contracts/PSP22/Utils/token-timelock",id:"smart-contracts/PSP22/Utils/token-timelock",isDocsHomePage:!1,title:"PSP22 Token Timelock",description:"This example shows how you can reuse the implementation of PSP22 Token Timelock utility for PSP22. This contract will lock user's PSP22 tokens until the time specified, when they can withdraw them.",source:"@site/docs/smart-contracts/PSP22/Utils/token-timelock.md",sourceDirName:"smart-contracts/PSP22/Utils",slug:"/smart-contracts/PSP22/Utils/token-timelock",permalink:"/smart-contracts/PSP22/Utils/token-timelock",editUrl:"https://github.com/Supercolony-net/openbrush-contracts/tree/main/docs/docs/smart-contracts/PSP22/Utils/token-timelock.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"PSP22 Token Timelock"},sidebar:"tutorialSidebar",previous:{title:"PSP22 Capped",permalink:"/smart-contracts/PSP22/Extensions/capped"},next:{title:"PSP721",permalink:"/smart-contracts/PSP721/psp721"}},p=[{value:"Step 1: Include dependencies and add imports",id:"step-1-include-dependencies-and-add-imports",children:[]},{value:"Step 2: Define storage",id:"step-2-define-storage",children:[]},{value:"Step 3: Inherit logic",id:"step-3-inherit-logic",children:[]},{value:"Step 4: Define constructor",id:"step-4-define-constructor",children:[]}],u={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This example shows how you can reuse the implementation of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Supercolony-net/openbrush-contracts/tree/main/contracts/token/psp22/src/utils/token_timelock.rs"},"PSP22 Token Timelock")," utility for ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Supercolony-net/openbrush-contracts/tree/main/contracts/token/psp22"},"PSP22"),". This contract will lock user's ",(0,i.kt)("inlineCode",{parentName:"p"},"PSP22")," tokens until the time specified, when they can withdraw them."),(0,i.kt)("h2",{id:"step-1-include-dependencies-and-add-imports"},"Step 1: Include dependencies and add imports"),(0,i.kt)("p",null,"Include dependencies to ",(0,i.kt)("inlineCode",{parentName:"p"},"psp22")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"brush")," in the cargo file. Then we need to replace ",(0,i.kt)("inlineCode",{parentName:"p"},"ink::contract")," macro by ",(0,i.kt)("inlineCode",{parentName:"p"},"brush::contract")," and import ",(0,i.kt)("strong",{parentName:"p"},"everything")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"psp22::traits")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"psp22::utils::token_timelock"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[brush::contract]\npub mod my_psp22_token_timelock {\n    use psp22::{\n        traits::*,\n        utils::token_timelock::*,\n    };\n")),(0,i.kt)("h2",{id:"step-2-define-storage"},"Step 2: Define storage"),(0,i.kt)("p",null,"Declare storage struct and declare the field related to the ",(0,i.kt)("inlineCode",{parentName:"p"},"PSP22TokenTimelockStorage")," trait. Then you need to derive the ",(0,i.kt)("inlineCode",{parentName:"p"},"PSP22TokenTimelockStorage")," trait and mark the corresponding field with ",(0,i.kt)("inlineCode",{parentName:"p"},"#[PSP22TokenTimelockStorageField]")," attribute. Deriving this trait allows you to reuse the default implementation of and ",(0,i.kt)("inlineCode",{parentName:"p"},"PSP22TokenTimelock"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[ink(storage)]\n#[derive(Default, PSP22TokenTimelockStorage)]\npub struct MyPSP22TokenTimelock {\n    #[PSP22TokenTimelockStorageField]\n    timelock: PSP22TokenTimelockData\n}\n")),(0,i.kt)("h2",{id:"step-3-inherit-logic"},"Step 3: Inherit logic"),(0,i.kt)("p",null,"Inherit the implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"PSP22TokenTimelock")," trait. You can customize (override) methods in this ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," block."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"impl PSP22TokenTimelock for MyPSP22TokenTimelock {}\n")),(0,i.kt)("h2",{id:"step-4-define-constructor"},"Step 4: Define constructor"),(0,i.kt)("p",null,"Define constructor. Your implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"PSP22TokenTimelock")," contract is ready!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"impl MyPSP22TokenTimelock {\n    #[ink(constructor)]\n    pub fn new(token_address: AccountId, beneficiary: AccountId, release_time: Timestamp) -> Self {\n        let mut instance = Self::default();\n        instance.init(token_address, beneficiary, release_time);\n        instance\n    }\n}\n")),(0,i.kt)("p",null,"You can also check the documentation for the basic implementation of ",(0,i.kt)("a",{parentName:"p",href:"/smart-contracts/PSP22/psp22"},"PSP22"),"."))}m.isMDXComponent=!0}}]);